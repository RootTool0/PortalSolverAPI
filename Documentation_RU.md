# Portal Solver API - Не дописана
**Portal Solver API** - данная документация является документацией продвинутого уровня, описывающая весь подкапотный **принцип работы API** игры: Как она принимает, загружает, создает и генерирует карты. На основе этой документации вы сможете разобраться и написать любые другие API для **Portal: Solver** на любом языке

## === Оглавление ===

### Основное:

#### Глава 1 - Что из себя представляет прием данных карты

#### Глава 2 - Структура JSON

#### Глава 2.1 - Структура JSON "StaticMeshes"

#### Глава 2.2 - Структура JSON "Elements"

#### Глава 2.3 - Структура JSON "Connections"

#### Глава 3 - Возможные коды/сообщения об ошибках и их теоретические решения


### Дополнительно:
#### Глава 4 - Подробнее об трансформации элементов и статичной геометрии

#### Глава 5 - Шпаргалка по StaticMeshAssetID и MaterialAssetID

#### Глава 6 - Шпаргалка по всем классам элементов и их свойствах

#### Глава 7 - Шпаргалка по упаковке значений

## Глава 1 - Что из себя представляет прием данных карты

Прежде, чем начать создавать данные, стоит разобраться, куда их вообще пересылать? В Portal: Solver мы решили максимально упростить задачу: На локальный IP в определённый порт

При запуске Python Editor, игра создает локальный HTTP сервер на порту **20563**. На этом сервере существует только лишь 3 end-point'a: "/build", "/run" и "/callbackping"

Каждый из них возвращает "OK" при успешном выполнении команды. Если результат иной - значит это ошибка (подробнее в Главе 3)

Разберем каждый end-point:

- "/build" - Данный end-point служит для загрузки карты и подготовки билдинга. В тело HTTP-запроса передается JSON данные карты (подробнее в Главе 2). Игра парсит JSON в внутреннюю структуру и подготавливает билдер к запуску

- "/run" - Крайне минималистичная функция, запускает билдер по сохранённой внутренней структуре. Обычно не имеет ошибок, ибо всю ответственность за корректность JSON я передаю вам, а от себя беру лишь ответственность на то, что корректный JSON правильно отпарсируется и его структура будет успешно прочитана билдером

    _P.S. Если будет произведен запуск "/run" без загрузки данных через "/build", то билдер создаст пустую карту (или соберет последнюю загруженную/сохранённую карту)_


- "/callbackping" - По сути - затычка. Никакой логической нагрузки не создает, а лишь возвращает "OK" при успешном выполнении, иначе - ошибка. Существует чисто для проверки, что HTTP сервер запущен и готов к работе
 
Итог: Теперь с помощью библиотеки cpr (C++), request (Python), HttpClient (C#), или даже в командой строке через curl (CMD), вы можете отправлять команды в Portal: Solver!

**C++:**
```cpp
#include <cpr/cpr.h>

auto Response = cpr::Post(cpr::Url{"http://127.0.0.1:20563/build"}, cpr::Body{"Your_JSON_Here"});
```

**Python:**
```python
import requests

requests.post("http://127.0.0.1:20563/build", data="Your_JSON_Here") # Or: json={...}
```

**C#:**
```csharp
using System.Net.Http;
using System.Text;

using var Client = new HttpClient();
using var Response = Client.PostAsync("http://127.0.0.1:20563/build", new StringContent("Your_JSON_Here")).Result;
```

**CMD:**
```bash
curl -X POST http://127.0.0.1:20563/build -d "Your_JSON_Here"
```

## Глава 2 -  Структура JSON

Теперь приступим к самой структуре минимально рабочего JSON, который принимает Portal: Solver. Тут все просто до безобразия:

```json
{
  "StaticMeshes": [],
  "Elements": {}, 
  "Connections": []
}
```

Первой проверкой является проверка на содержания этих трех основных полей, иначе - остановка и возврат ошибки парсинга (подробнее в Главе 3)

Теперь перейдем к разбору JSON'ов внутри

## Глава 2.1 - Структура JSON "StaticMeshes"

Внутри массива "StaticMeshes" хранится JSON объект формата:

```json
{
  "Transform": {
    "Location": [0, 0, 0],
    "Rotation": [0, 0, 0],
    "Scale": [1, 1, 1]
  },
  "StaticMeshAssetID": 0,
  "MaterialAssetID": 0
}
```

Трансформация указывается в глобальной системе координат, а расшифровка обозначений StaticMeshAssetID и MaterialAssetID - подробно расписано в Главе #TODO#

## Глава 2.2 - Структура JSON "Elements"

Внутри объекта "StaticMeshes" хранятся **именованные** JSON

объекты формата:
```json
"ElementName": {
  "Transform": {
    "Location": [0, 0, 0],
    "Rotation": [0, 0, 0],
    "Scale": [1, 1, 1]
    },
    "Class": "DoorElement",
    "Properties": {
      "ColorActivated": 255
      "ColorDeactivated": 0
      "bState": 1
    },
    "MaterialAssetID": 0
}
```

Заметьте, что вначале указывается "ElementName" - уникальное название элемента, используемое для создания связей (подробнее в Главе 2.3)
Трансформация указывается в глобальной системе координат. Про Propeties все более интереснее -
